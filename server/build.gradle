buildscript {
    ext {
        appVersion = "0.0.1"
        // versions (ordered alphabetically)
        flywayVersion = "5.0.7"
        jwtVersion = "0.9.0"
        lombokVersion = "1.18.10"
        nodePluginVersion = "1.2.0"
        propdepsPluginVersion = "0.0.9.RELEASE"
        refVersion = "0.9.11"
        springBootVersion = "2.0.2.RELEASE"
        // other vars
        apiDocsFolder = "apidocs"
        buildPropertiesFilePath = "./build/resources/main/application.properties"
        envSet = false
        snippetsDir = file("build/generated-snippets")
    }
    repositories {
        mavenLocal()
        mavenCentral()
        maven { url "http://repo.spring.io/plugins-release" }
        maven { url "https://plugins.gradle.org/m2/" }
    }
    dependencies {
        classpath "org.springframework.boot:spring-boot-gradle-plugin:${springBootVersion}"
        classpath "com.moowork.gradle:gradle-node-plugin:${nodePluginVersion}"
        classpath "io.spring.gradle:propdeps-plugin:${propdepsPluginVersion}"
    }
}

plugins {
    id "org.asciidoctor.convert" version "2.3.0"
    // coverage reports for coveralls.io
    id "net.saliman.cobertura" version "2.6.1"
    id "com.github.kt3k.coveralls" version "2.8.4"
}

apply plugin: "io.spring.dependency-management"
apply plugin: "propdeps"
apply plugin: "propdeps-maven"
apply plugin: "propdeps-idea"
apply plugin: "propdeps-eclipse"
apply plugin: "java"
apply plugin: "eclipse"
apply plugin: "idea"
apply plugin: "org.springframework.boot"
apply plugin: "war"
apply plugin: "com.moowork.node"
apply plugin: "org.asciidoctor.convert"
apply plugin: "net.saliman.cobertura"
apply plugin: "com.github.kt3k.coveralls"

group = "com.gms"
version = "${appVersion}"
sourceCompatibility = 1.8

repositories {
    mavenLocal()
    mavenCentral()
}

node {
    download = false
    nodeModulesDir = file("../client")
}

dependencies {
    compile ("org.springframework.boot:spring-boot-starter-hateoas")
    compile ("org.springframework.boot:spring-boot-starter-data-jpa")
    compile ("org.springframework.boot:spring-boot-starter-data-rest")
    compile ("org.springframework.boot:spring-boot-starter-mail")
    compile ("org.springframework.boot:spring-boot-starter-security")
    compile ("io.jsonwebtoken:jjwt:${jwtVersion}")
    compile ("org.springframework.boot:spring-boot-starter-web")
    compile ("org.reflections:reflections:${refVersion}")
    compile ("org.flywaydb:flyway-core:${flywayVersion}")
    compileOnly ("org.projectlombok:lombok:${lombokVersion}")
    annotationProcessor ("org.projectlombok:lombok:${lombokVersion}")
    runtime ("org.springframework.boot:spring-boot-devtools")
    runtime ("org.postgresql:postgresql")
    testCompile ("com.jayway.jsonpath:json-path")
    testCompile ("org.springframework.boot:spring-boot-starter-test")
    testCompile ("org.springframework.restdocs:spring-restdocs-mockmvc")
    testCompile ("org.springframework.security:spring-security-test")
    optional ("org.springframework.boot:spring-boot-configuration-processor")
}

//region custom tasks

//region client task
task clientBuild(type: NpmTask, dependsOn: ["npmInstall", "copyClientDocBuild",  "configPackageJsonDeployUrl", "configPackageJsonBaseUrl"]) {
    group = "client tasks"
    description = "Compiles client side folder for production"
    args = ["run", "build"]
}

task configPackageJsonDeployUrl(type: NpmTask) {
    group = "client tasks"
    description = "Sets the configuration variable 'deployUrl' in the package.json#config"
    args = ["config", "set", "client:deployUrl", getClientDeployUrl()]
}

task configPackageJsonBaseUrl(type: NpmTask) {
    group = "client tasks"
    description = "Sets the configuration variable 'baseUrl' in the package.json#config"
    args = ["config", "set", "client:baseUrl", getClientBaseUrl()]
}

task copyClientBuild(type: Copy, dependsOn: ["clientBuild"]) {
    group = "client tasks"
    description = "Checks all client side resources are ready for deployment and copy them into the `static` folder"
    from "../client/dist"
    into "build/resources/main/static"
}

task clientDocBuild(type: NpmTask, dependsOn: ["npmInstall"]) {
    group = "client tasks"
    description = "Compiles client side documentation folder for production"
    args = ["run", "builddoc"]
}

task copyClientDocBuild(type: Copy, dependsOn: ["clientDocBuild"]) {
    group = "client tasks"
    description = "Checks all client app documentation resources are ready for deployment and copy them into the `static` folder"
    from "../client/documentation"
    into "build/resources/main/static/appdocs"
}

task cleanAll(type: Delete, dependsOn: ["clean"]) {
    group = "build"
    description = "Deletes de build directory from server and client modules"
    delete '../client/documentation', '../client/dist', '../client/coverage'
    followSymlinks = true
}
//endregion

//region environments config
task setDevConfig() {
    group = "other"
    description = "Sets the environment for development mode"
    doFirst {
        def p = getSpringAppPropertyInBuild("spring.profiles.active")
        if (p && p  != "development") {
            ant.propertyfile(file: buildPropertiesFilePath) {
                entry(key: "spring.profiles.active", value: "development")
            }
            envSet = true
        }
    }
    doLast {
        if (getSpringAppPropertyInBuild("spring.profiles.active") == "development") {
            println "Environment set for development mode..."
        }
    }
}

task setTestingConfig() {
    group = "other"
    description = "Sets the environment for testing mode"
    doFirst {
        def p = getSpringAppPropertyInBuild("spring.profiles.active")
        if (p && p != "test") {
            ant.propertyfile(file: buildPropertiesFilePath) {
                entry(key: "spring.profiles.active", value: "test")
            }
            envSet = true
        }
    }
    doLast {
        if (getSpringAppPropertyInBuild("spring.profiles.active") == "test") {
            println "Environment set for testing mode..."
        }
    }
}

task setProductionConfig() {
    group = "other"
    description = "Sets the environment for production mode"
    doFirst {
        def p = getSpringAppPropertyInBuild("spring.profiles.active")
        if (p && p  != "production") {
            ant.propertyfile(file: buildPropertiesFilePath) {
                entry(key: "spring.profiles.active", value: "production")
            }
            envSet = true
        }
    }
    doLast {
        if (getSpringAppPropertyInBuild("spring.profiles.active") == "production") {
            println 'Environment set for production mode...'
        }
    }
}

@SuppressWarnings("GrMethodMayBeStatic")
private String getSpringAppPropertyInBuild(String key, String filePath = null){
    def props = new Properties()
    def propFile = new File(filePath ?: buildPropertiesFilePath)
    def p = null

    if (propFile.exists() && propFile.canRead()){
        props.load(new FileInputStream(propFile))
        if (props!=null && props.containsKey(key)) {
            p = props[key]
        }
    }
    return p
}

//endregion

//region control enabled tasks
npmInstall.enabled = installClientDependencies()
clientBuild.enabled = buildClient()
copyClientBuild.enabled = buildClient()
clientDocBuild.enabled = buildDocClient()
copyClientDocBuild.enabled = buildDocClient()

task disableNpmInstallTask(type: Exec) {
    group = "other"
    description = "Resets the state of the npmInstall task to disable once it has ran"
    doLast {
        npmInstall.enabled = false
    }
}
disableNpmInstallTask.mustRunAfter(npmInstall)

task resetConfigTaskState(type: Exec) {
    group = "other"
    description = "Resets the custom tasks to their original state"
    doLast {
        npmInstall.enabled = installClientDependencies()
        clientBuild.enabled = buildClient()
        copyClientBuild.enabled = buildClient()
        clientDocBuild.enabled = buildDocClient()
        copyClientDocBuild.enabled = buildDocClient()
        setDevConfig.enabled = true
        setTestingConfig.enabled = true
        setProductionConfig.enabled = true
    }
}
//endregion

//region api docs
asciidoctor {
    //noinspection GroovyAssignabilityCheck
    attributes "snippets": snippetsDir
    inputs.dir snippetsDir
    outputDir "build/asciidoc"
    dependsOn test
    sourceDir "src/main/asciidoc"
}

task processApiDocs(type: Copy, dependsOn: asciidoctor) {
    group = "build"
    description = "Copies de api documentation to the destinated folder"
    from "${asciidoctor.outputDir}/html5"
    into "build/resources/main/static/" + (apiDocsFolder as String)
}
//endregion

//endregion

cobertura.coverageFormats = ['html', 'xml'] // coveralls plugin depends on xml format report

resetConfigTaskState.mustRunAfter(bootRun, bootWar, clean)

clean.dependsOn(setDevConfig)
bootRun.dependsOn(setDevConfig)

test {
    dependsOn setTestingConfig
    outputs.dir snippetsDir
}

testClasses.dependsOn(setTestingConfig)

bootWar {
    dependsOn setProductionConfig, processApiDocs, copyClientBuild
    baseName = getAppName()
}

// In order to generate our own metadata by Using the Annotation Processor
compileJava.dependsOn(processResources)

private boolean buildClient() {
    return Boolean.parseBoolean(project.getProperties().get("client").toString())
}

private boolean installClientDependencies() {
    return Boolean.parseBoolean(project.getProperties().get("clientDependencies").toString())
}

private boolean buildDocClient() {
    return Boolean.parseBoolean(project.getProperties().get("clientDoc").toString())
}

private String getAppName() {
    return getSpringAppPropertyInBuild("spring.application.name", "./src/main/resources/application.properties")
}

private String getClientDeployUrl() {
    String defaultUrl = "/${getAppName()}-${version}/"
    String configUrl  = project.getProperties().get("clientDeployUrl")
    return (configUrl || configUrl == "<default>") ? (configUrl == "<default>" ? "" : configUrl) : defaultUrl
}

private String getClientBaseUrl() {
    String defaultUrl = "/${getAppName()}-${version}/"
    String configUrl  = project.getProperties().get("clientBaseUrl")
    return configUrl ? configUrl : defaultUrl
}